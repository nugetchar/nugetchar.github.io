---
layout: post
title: "JS Warmup - Observables"
date: 2020-10-24 15:00:00 +0200
categories: [code, javascript, warm-up, exercises, Observables]
---

# JS Warmup

![Ã§a va bien se passer](https://media.giphy.com/media/jqeTaaiD3rLKE/giphy.gif)

_Ã‡a va bien se passer_

## Exercice 1 - On commence doucement

Codez une fonction `sum` prenant un nombre indÃ©fini de paramÃ¨tres et retournant la somme des nombres.

## Exercice 2 - Escalade VÃ©loce ðŸš€

### 2A

Ecrivez une fonction `isFunction` qui prend un paramÃ¨tre et qui vÃ©rifie qu'il s'agisse bien d'une fonction. Aidez vous de l'opÃ©rateur [`typeof`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_typeof).

`isFunction` devra fonctionner comme suit :

```js
const f1 = () => {};
function f2() {}
const nombre = 12;

isFunction(f1); // retourne true
isFunction(f2); // retourne true
isFunction(nombre); // retourne false
```

### 2B

Ecrivez une fonction `filterNonFunctions` qui prend en paramÃ¨tre un nombre indÃ©fini d'arguments sous la forme d'un _rest parameter_ et qui retourne un tableau ne contenant **que** les arguments Ã©tant des fonctions.
Pour cela, aidez-vous de la mÃ©thode `filter` du prototype `Array`.

Elle devra fonctionner comme suit :

```js
const f1 = () => {};
function f2() {}
const nombre = 12;

const functions = filterNonFunctions(f1, nombre, f2); // [f1, f2]
```

### 2C

Ecrivez dÃ©sormais une fonction `pipe` qui fonctionne comme suit : - nombre indÃ©fini de fonctions en entrÃ©e ; - filtre les arguments qui ne sont pas des fonctions ; - stocke le tableau rÃ©sultant du filtre ; - retourne une nouvelle fonction - prenant un nombre indÃ©fini d'arguments ; - exÃ©cute chaque fonction `n` en lui passant en argument le rÃ©sultat de l'appel `n - 1` ; - retourne le rÃ©sultat final.

Exemple :

```js
// On a des fonctions de base
const multiply = (x, y) => x * y;
const square = (x) => x * x;
const double = (y) => y * 2;
const addTen = (z) => z + 10;

// pipe prend un nombre indÃ©fini de fonctions en argument
// Ici, on crÃ©e trois nouvelles fonctions
const piped1 = pipe(multiply, square, double, addTen);
const piped2 = pipe(square, double);
const piped3 = pipe();

// piped1(2, 3) va exÃ©cuter Ã  la suite :
// multiply(2, 3), square(6), double(36), addTen(72)
const result1 = piped1(2, 3);

// piped2(4) va exÃ©cuter Ã  la suite :
// square(4), double(16)
const result2 = piped2(4);

// piped3 ne va rien exÃ©cuter
const result3 = piped3();

console.log(result1); // affiche 86
console.log(result2); // affiche 32
console.log(result3); // undefined
```

## Exercice 3 - Same, but different

Ecrivez une fonction `compose` qui fonctionne comme suit :

```js
const multiply = (x, y) => x * y;
const square = (x) => x * x;
const double = (y) => y * 2;
const addTen = (z) => z + 10;

// compose prend un nombre indÃ©fini de fonctions en argument
// et retourne une nouvelle fonction
const composed1 = compose((x) => multiply(x, 3), square, double, addTen);
const composed2 = compose(square, double);
// la nouvelle fonction prend un nombre indÃ©fini d'arguments
// et exÃ©cute les diffÃ©rentes fonctions comme une composition mathÃ©matique
const result1 = composed1(2);
const result2 = composed2(4);

console.log(result1); // affiche 1728
console.log(result2); // affiche 64
```

_Indice : `compose` est le pendant de `pipe` : au lieu d'exÃ©cuter les fonctions dans l'ordre passÃ©, elle les exÃ©cute dans l'ordre inverse (type `f(g(x))`)_

## Exercice 4 - Promises et Observables

### 4A

Allez lire la documentation sur [les Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) avant de faire l'exercice.

Ecrivez une fonction `delay` qui fonctionne comme suit :

```js
const multiply = (x, y) => x * y;

// delay prend en paramÃ¨tre une fonction et un timeout (millisecondes)
// et retourne une nouvelle fonction qui :
// - retournera une Promise
// - exÃ©cutera la fonction (ici multiply) aprÃ¨s le timeout
const delayed = delay(multiply, 2000);
delayed(3, 4).then((res) => console.log(res)); // affichera 12 aprÃ¨s 2s
```

### 4B

On a la classe suivante :

```js
class Observable {
  // rest parameters
  constructor(...args) {
    // on ne fait pas "this.values"
    // afin que le champ reste privÃ©
    let values = args;
    // idem avec subscribers, qui sera un tableau de fonctions
    const subscribers = [];
    // la mÃ©thode "next" prend des rest parameters en entrÃ©e
    this.next = (...vals) => {
      // elle met Ã  jours "values"
      values = [...vals];
      // et dÃ©clenche tous les traitements avec ces nouvelles valeurs
      subscribers.forEach((f) => f(...values));
    };
    // "subscribe" enregistre simplement une nouvelle fonction
    // qui sera exÃ©cutÃ©e Ã  la prochaine valeur Ã©mise par "next"
    this.subscribe = (f) => {
      subscribers.push(f);
    };
  }
}
```

En vous aidant de cette classe, Ã©crivez une fonction `debounce` de sorte Ã  ce que le code suivant fonctionne :

```js
const square = (x) => x ** 2;

// "debounce" prend une fonction ainsi qu'un timeout en paramÃ¨tre
// et retourne un Observable
const debounced = debounce(square, 1000);

const subscriber = (res) => console.log("res", res);

// (1) DEVRAIT exÃ©cuter square aprÃ¨s 1s et afficher 9
debounced(3).subscribe((res) => console.log("res", res));
// (2) se dÃ©clenchera aprÃ¨s 1.5s, exÃ©cutera square et affichera 4
setTimeout(() => debounced(2), 1500);
debounced(10); // (3) annulera l'appel (1) et relancera un nouveau timeout
```

Indices :

- vous pouvez vous aider de [cet article](https://dev.to/nugetchar/debounce-and-throttle-47cd), Ã©crit par votre humble intervenant. Par contre l'implÃ©mentation qui s'y trouve n'est pas _totalement_ celle demandÃ©e ici ðŸ™ƒ.

### 4C

Reprenez la fonction `delay` et, au lieu de retourner une `Promise`, retournez un `Observable`.

### 4D

Dans la classe `Observable`, implÃ©mentez une mÃ©thode `pipe` : contrairement Ã  la premiÃ¨re fonction codÃ©e dans les prÃ©cÃ©dents exercices, celle-ci ne retournera pas une fonction mais exÃ©cutera directement les fonctions passÃ©es en paramÃ¨tre et retournera un `Observable` contenant le rÃ©sultat.

Le code suivant doit fonctionner :

```js
class Observable {
  constructor(...args) {
    let values = args;
    const subscribers = [];
    this.next = (...vals) => {
      values = [...vals];
      subscribers.forEach((f) => f(...values));
    };
    this.subscribe = (f) => {
      subscribers.push(f);
      f(...values);
    };
    this.pipe = (...functions) => {
      // TODO: implÃ©mentez cette mÃ©thode
      // Pensez Ã  filtrer les arguments qui ne sont pas des fonctions
      // Vous devez retourner un Observable comportant le rÃ©sultat final
      // Pour le reste, c'est sensiblement pareil que la prÃ©cÃ©dente
      // fonction pipe()
    };
  }
}

new Observable(4)
  .pipe(
    (x) => x ** 2,
    (x) => ("" + x).split(""),
    (numbers) => numbers.map((x) => +x),
    (numbers) => numbers.reduce((acc, curr) => acc + curr, 0)
  )
  .subscribe((res) => console.log("resultat", res)); // 7
```
